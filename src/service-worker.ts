// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { registerRoute, NavigationRoute, Route } from 'workbox-routing';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { CacheFirst, NetworkFirst, StaleWhileRevalidate, NetworkOnly } from 'workbox-strategies';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { ExpirationPlugin } from 'workbox-expiration';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { warmStrategyCache } from 'workbox-recipes';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { BackgroundSyncPlugin } from 'workbox-background-sync';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { Queue } from 'workbox-background-sync';

// Clean up outdated caches
cleanupOutdatedCaches();

// Precache all assets generated by your build process
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
precacheAndRoute(self.__WB_MANIFEST);

// Add a utility function at the beginning of the file 
// to safely check if a URL can be cached
function isValidCacheURL(url: string): boolean {
  try {
    const urlObj = new URL(url);
    const validProtocols = ['http:', 'https:'];
    return validProtocols.includes(urlObj.protocol);
  } catch (e) {
    console.error('Invalid URL:', url, e);
    return false;
  }
}

// Define URLs to preload/warm up cache - only essential UI assets
const URLS_TO_CACHE = [
  '/',
  '/index.html',
  '/manifest.json',
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png',
  '/offline.html'
];

// Cache critical static assets with a Cache First strategy
const staticAssetsStrategy = new CacheFirst({
  cacheName: 'static-assets-v3',
  plugins: [
    new CacheableResponsePlugin({
      statuses: [0, 200],
    }),
    new ExpirationPlugin({
      maxEntries: 100, // Reduced from 200
      maxAgeSeconds: 24 * 60 * 60, // 1 day (reduced from 90 days)
      purgeOnQuotaError: true
    }),
  ],
});

// Warm up the cache with critical assets
warmStrategyCache({
  urls: URLS_TO_CACHE,
  strategy: staticAssetsStrategy
});

// Cache images with a Cache First strategy - reduced caching
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ request, url }: { request: any, url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    // Only cache essential UI images
    return request.destination === 'image' && 
           (url.pathname.includes('/icons/') || 
            url.pathname.includes('/images/ui/'));
  },
  new CacheFirst({
    cacheName: 'essential-images-v3',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50, // Reduced from 150
        maxAgeSeconds: 24 * 60 * 60, // 1 day (reduced from 90 days)
        purgeOnQuotaError: true // Delete old entries when cache is full
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Cache CSS and JavaScript with a Network First strategy - always try network first
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ request, url }: { request: any, url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return request.destination === 'script' ||
           request.destination === 'style';
  },
  new NetworkFirst({
    cacheName: 'static-resources-v3',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50, // Reduced from 150
        maxAgeSeconds: 24 * 60 * 60, // 1 day (reduced from 30 days)
        purgeOnQuotaError: true // Delete old entries when cache is full
      }),
    ],
  })
);

// Optimized caching for fonts - limited caching
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ request, url }: { request: any, url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return request.destination === 'font' || 
           url.origin.includes('fonts.googleapis.com') ||
           url.origin.includes('fonts.gstatic.com');
  },
  new CacheFirst({
    cacheName: 'fonts-v3',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 20, // Reduced from 50
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days (reduced from 1 year)
        purgeOnQuotaError: true // Delete old entries when cache is full
      }),
    ],
  })
);

// Network Only for all API routes and analytics - never cache these
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    
    // Match all API endpoints and analytics - never cache them
    return url.pathname.includes('/api/') || 
           url.pathname.includes('/rest/') ||
           url.pathname.includes('/supabase/') ||
           url.pathname.includes('/_vercel/insights') ||
           url.pathname.includes('/vercel/insights');
  },
  new NetworkOnly()
);

// Enhanced caching for critical pages - improved implementation, but use NetworkFirst
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    
    // Cache main app routes, but with NetworkFirst strategy
    return url.pathname === '/' || 
           url.pathname === '/upcoming' || 
           url.pathname === '/search' ||
           url.pathname === '/routine' || 
           url.pathname === '/home' ||
           url.pathname === '/courses' ||
           url.pathname === '/profile';
  },
  new NetworkFirst({
    cacheName: 'app-pages-v3',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 10, // Reduced from 25
        maxAgeSeconds: 60 * 60, // 1 hour (reduced from 24 hours)
        purgeOnQuotaError: true
      })
    ]
  })
);

// Create a separate NavigationRoute with its own NetworkFirst strategy
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const navigationRoute = new NavigationRoute(new NetworkFirst({
  cacheName: 'navigations-v3',
  plugins: [
    new CacheableResponsePlugin({
      statuses: [0, 200],
    }),
    new ExpirationPlugin({
      maxEntries: 10,
      maxAgeSeconds: 60 * 60, // 1 hour
      purgeOnQuotaError: true
    })
  ]
}), {
  // Disable caching for API routes and admin pages
  denylist: [/\/api\//, /\/admin\//, /\/rest\//]
});

// Register the navigation route
registerRoute(navigationRoute);

// Create task queue for background sync
const taskSyncQueue = new Queue('taskQueue', {
  maxRetentionTime: 24 * 60, // Retry for up to 24 Hours
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request.clone());
        console.log('Sync successful for task operation');
        
        // Notify the client that sync is complete
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const clients = await (self as any).clients.matchAll({ type: 'window' });
        for (const client of clients) {
          client.postMessage({
            type: 'BACKGROUND_SYNC_COMPLETED',
            category: 'task'
          });
        }
      } catch (error) {
        console.error('Sync failed for task:', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  }
});

// Create routine queue for background sync
const routineSyncQueue = new Queue('routineQueue', {
  maxRetentionTime: 24 * 60, // Retry for up to 24 Hours
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request.clone());
        console.log('Sync successful for routine operation');
        
        // Notify the client that sync is complete
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const clients = await (self as any).clients.matchAll({ type: 'window' });
        for (const client of clients) {
          client.postMessage({
            type: 'BACKGROUND_SYNC_COMPLETED',
            category: 'routine'
          });
        }
      } catch (error) {
        console.error('Sync failed for routine:', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  }
});

// Create course/teacher queue for background sync
const courseTeacherSyncQueue = new Queue('courseTeacherQueue', {
  maxRetentionTime: 24 * 60, // Retry for up to 24 Hours
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request.clone());
        console.log('Sync successful for course/teacher operation');
        
        // Notify the client that sync is complete
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const clients = await (self as any).clients.matchAll({ type: 'window' });
        for (const client of clients) {
          client.postMessage({
            type: 'BACKGROUND_SYNC_COMPLETED',
            category: 'courseTeacher'
          });
        }
      } catch (error) {
        console.error('Sync failed for course/teacher:', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  }
});

// Create background sync plugins
const taskBgSyncPlugin = new BackgroundSyncPlugin('taskQueue', {
  maxRetentionTime: 24 * 60 // Retry for up to 24 Hours
});

const routineBgSyncPlugin = new BackgroundSyncPlugin('routineQueue', {
  maxRetentionTime: 24 * 60 // Retry for up to 24 Hours
});

const courseTeacherBgSyncPlugin = new BackgroundSyncPlugin('courseTeacherQueue', {
  maxRetentionTime: 24 * 60 // Retry for up to 24 Hours
});

// Handle API requests with NetworkOnly
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    // Skip unsupported URL schemes
    if (url.protocol === 'chrome-extension:' || 
        url.protocol === 'chrome:' ||
        url.protocol === 'edge:' ||
        url.protocol === 'brave:') {
      return false;
    }
    return url.pathname.match(/\/api\/.*/);
  },
  new NetworkOnly()
);

// Handle sync events directly
// eslint-disable-next-line @typescript-eslint/no-explicit-any
self.addEventListener('sync', (event: any) => {
  console.log('Sync event received:', event.tag);
  
  if (event.tag === 'taskSync') {
    event.waitUntil(taskSyncQueue.replayRequests());
  } else if (event.tag === 'routineSync') {
    event.waitUntil(routineSyncQueue.replayRequests());
  } else if (event.tag === 'courseTeacherSync') {
    event.waitUntil(courseTeacherSyncQueue.replayRequests());
  }
});

// Add a global error handler to catch unexpected errors
self.addEventListener('error', (event) => {
  console.error('Service Worker error:', event.error);
});

// Add an unhandled rejection handler
self.addEventListener('unhandledrejection', (event) => {
  console.error('Service Worker unhandled rejection:', event.reason);
});

// Add a message handler for keep-alive pings
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'KEEP_ALIVE') {
    console.log('Keep-alive ping received at', new Date(event.data.timestamp).toISOString());
    
    // Respond to the keep-alive to confirm service worker is active
    if (event.source) {
      event.source.postMessage({
        type: 'KEEP_ALIVE_RESPONSE',
        timestamp: Date.now()
      });
    }
    
    // Reset any internal timers to keep the service worker active
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    self.registration.active?.postMessage({
      type: 'INTERNAL_KEEP_ALIVE'
    });
  } else if (event.data && event.data.type === 'SYNC_NOW') {
    console.log('SYNC_NOW message received, attempting immediate sync');
    
    // Try to perform sync for all queues
    Promise.allSettled([
      taskSyncQueue.replayRequests(),
      routineSyncQueue.replayRequests(),
      courseTeacherSyncQueue.replayRequests()
    ]).then(results => {
      console.log('Sync attempts completed:', results);
      
      // Notify client that sync was attempted
      if (event.source) {
        event.source.postMessage({
          type: 'SYNC_NOW_COMPLETED',
          results: results.map(r => r.status)
        });
      }
    });
  } else if (event.data && event.data.type === 'CLEAR_ALL_CACHES') {
    console.log('CLEAR_ALL_CACHES message received, clearing all caches');
    
    // Clear all caches
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          console.log('Deleting cache:', cacheName);
          return caches.delete(cacheName);
        })
      );
    }).then(() => {
      console.log('All caches cleared successfully');
      
      // Notify client that caches were cleared
      if (event.source) {
        event.source.postMessage({
          type: 'CACHES_CLEARED',
          timestamp: Date.now()
        });
      }
    });
  }
});